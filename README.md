### 什么是 Java 内存模型？

同样的一段代码，可能在处理器 A 上运行正常，而在处理器 B 上运行的结果却不一致。同理，在没有 JMM 之前，不同的 JVM 的实现，也会带来不一样的“翻译”结果。

所以 Java 非常需要一个标准，来让 Java 开发者、编译器工程师和 JVM 工程师能够达成一致。
达成一致后，我们就可以很清楚的知道什么样的代码最终可以达到什么样的运行效果，让多线程运行结果可以预期，这个标准就是 JMM，这就是需要 JMM 的原因。

研究从 Java 代码到 CPU 指令的这个转化过程要遵守哪些和并发相关的原则和规范，这就是 JMM 的重点内容。

JMM（Java Memory Model，Java 内存模型）

JMM 是和多线程相关的一组规范，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。
这样一来，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的。

因此，JMM 与处理器、缓存、并发、编译器有关。
它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。

比如我们写了关键字 synchronized，JVM 就会在 JMM 的规则下，“翻译”出合适的指令，包括限制指令之间的顺序，以便在即使发生了重排序的情况下，
也能保证必要的“可见性”，这样一来，不同的 JVM 对于相同的代码的执行结果就变得可预期了，
我们 Java 程序员就只需要用同步工具和关键字就可以开发出正确的并发程序了，这都要感谢 JMM。

JMM 里最重要 3 点内容，分别是：重排序、原子性、内存可见性。

### 什么是重排序？

假设我们写了一个 Java 程序，包含一系列的语句，我们会默认期望这些语句的实际运行顺序和写代码顺序一致。
但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序。

重排序的好处：提高处理速度。

```
// 主存中读取 a 的值，然后把值设置为 100，并存储回去
load -> set -> store
```

重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。

重排序的 3 种情况：

- 编译器优化

>编译器（包括 JVM、JIT 编译器等），
例如当前有了数据 a，把对 a 的操作放到一起效率会更高，避免读取 b 后又返回来重新读取 a 的时间开销，此时在编译的过程中会进行一定程度的重排。
不过重排序并不意味着可以任意排序，它需要需要保证重排序后，不改变单线程内的语义，否则如果能任意排序的话，程序早就逻辑混乱了。

- CPU 重排序

>CPU 同样会有优化行为，这里的优化和编译器优化类似，都是通过乱序执行的技术来提高整体的执行效率。
所以即使之前编译器不发生重排，CPU 也可能进行重排，我们在开发中，一定要考虑到重排序带来的后果。

- 内存的“重排序”

>由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。

### Java 中的原子操作有哪些注意事项？

原子操作是指一系列的操作，要么全部发生，要么全部不发生，不会出现执行一半就终止的情况。

### 什么是 “内存可见性” 问题？

使用了 synchronized 之后，它会设立一个临界区，这样临界区内最多同时只有一个线程执行操作，
同时还保证了在前一个线程释放锁之后，之前所做的所有修改，都能被获得同一个锁的下一个线程所看到，也就是能读取到最新的值。
因为如果其他线程看不到之前所做的修改，依然也会发生线程安全问题。

### 主内存和工作内存的关系？

- 每个线程只能够直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 JMM 控制的。

- 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。

- 线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改；

- 每个线程有自己的工作内存，其中存储的是变量的副本，所以这个副本就有可能是过期的。

我们来举个例子：如果一个变量 x 被线程 A 修改了，只要还没同步到主内存中，线程 B 就看不到，所以此时线程 B 读取到的 x 值就是一个过期的值，这就导致了可见性问题。




































































































同步互斥锁？？？

CAS 操作？？？

它被 volatile 修饰，我们就可以保证在多线程之间看到的 value 是同一份，保证了可见性。
